<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一、Spring Boot 核心之自动装配实现]]></title>
    <url>%2F2019%2F11%2F24%2F2019-11-24-%20%20%E4%B8%80%E3%80%81Spring%20Boot%20%E6%A0%B8%E5%BF%83%E4%B9%8B%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[一、简介和目标 简介：在 Spring Boot 场景下，基于约定大于配置的原则，实现 Spring 组件自动装配的目的。 目标：完成一个可通过配置和@EnableXXX 来控制的是否装配的Bean 二、底层装配技术简述 Spring 模式注解装配 Spring @Enable 模块装配 注解驱动方式 eg: 123456@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE) @Documented@Import(DelegatingWebMvcConfiguration.class) public @interface EnableWebMvc &#123;&#125; 1234@Configuration public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; &#125; 接口编程方式 eg: 1234567@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Import(CachingConfigurationSelector.class) public @interface EnableCaching &#123; &#125; 123456789101112public class CachingConfigurationSelector extends AdviceModeImportSelector&lt;EnableCaching&gt; &#123; public String[] selectImports(AdviceMode adviceMode) &#123; switch(adviceMode) &#123; case PROXY: return this.getProxyImports(); case ASPECTJ: return this.getAspectJImports(); default: return null; &#125; &#125; &#125; Spring 条件装配 配置方式 - @Profile，根据不同环境进行装配 编程方式 - @Conditional 123456789@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Conditional(&#123;OnClassCondition.class&#125;)public @interface ConditionalOnClass &#123; Class&lt;?&gt;[] value() default &#123;&#125;; String[] name() default &#123;&#125;;&#125; Spring 工厂加载机制 实现类： SpringFactoriesLoader 配置资源： META-INF/spring.factories三、实现1、激活自动装配 @EnableAutoConfiguration项目结构如下添加核心Bean=&gt;HelloWorld,只有一个hello方法用于测试输出结果123456@Slf4jpublic class HelloWorld &#123; public void hello()&#123; log.info("hello world 2019!"); &#125;&#125; 添加HelloWorldConfiguration用于注册HelloWorld 12345678@Slf4jpublic class HelloWorldConfiguration &#123; @Bean public HelloWorld hello()&#123; log.info("Load HelloWorld"); return new HelloWorld(); &#125;&#125; 添加HelloWorldImportSelector实现ImportSelector，通过接口编程方式实现@Enable功能 12345678910@Slf4jpublic class HelloWorldImportSelector implements ImportSelector &#123; @Override public String[] selectImports(AnnotationMetadata annotationMetadata) &#123; log.info("annotationMetadata.getAnnotationTypes():&#123;&#125;",annotationMetadata.getAnnotationTypes()); // 此处可写分支条件，根据指定条件选择性注册某些类 或者返回null return new String[]&#123;HelloWorldConfiguration.class.getName()&#125;; &#125;&#125; 添加@EnableHelloWorld用于控制是否装配HelloWorld 1234567@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@Documented//@Import(HelloWorldConfiguration.class) // 基于注解驱动实现Sprig @Enable模块@Import(HelloWorldImportSelector.class) // 基于接口驱动实现Spring @Enable模块public @interface EnableHelloWorld &#123;&#125; 注:如果直接使用@Import(HelloWorldConfiguration.class)注解方式实现，则不需要HelloWorldImportSelector类，但是注解方式无法添加分支判断，只能指定加载指定类 2、实现自动装配配置类 HelloWorldAutoConfiguration123456@Configuration // 模式注解，声明是一个bean@ConditionalOnSystemProperty(name = "user.name", value = "Administrator") // 正确的条件装配//@ConditionalOnSystemProperty(name = "user.name", value = "lxt") // 错误的条件装配@EnableHelloWorld // Spring @Enable 模块装配public class HelloWorldAutoConfiguration &#123;&#125; 先根据条件注解@ConditionalOnSystemProperty判断是否满足 满足则执行@EnableHelloWorld，加载HelloWorldImportSelector，注册HelloWorldConfiguration进而注册HelloWorld3、配置自动装配实现 META-INF/spring.factories在resources下添加META-INF/spring.factories配置文件，用于启动是通过工厂机制（SpringFactoriesLoader）加载123# 自动装配org.springframework.boot.autoconfigure.EnableAutoConfiguration=\com.lxt.springboot.autoconfigure.configuration.HelloWorldAutoConfiguration 4、测试添加测试类HelloWorldService 123456789101112@Componentpublic class HelloWorldService &#123; @Autowired private HelloWorld helloWorld; @PostConstruct public void init()&#123; helloWorld.hello(); &#125;&#125; 启动项目，控制台输出如下，测试开启情况成功 1232019-11-24 21:25:02.299 INFO 13880 --- [ main] c.l.s.a.a.HelloWorldImportSelector : annotationMetadata.getAnnotationTypes():[com.lxt.springboot.autoconfigure.condition.ConditionalOnSystemProperty, com.lxt.springboot.autoconfigure.annotation.EnableHelloWorld]2019-11-24 21:25:02.710 INFO 13880 --- [ main] c.l.s.a.c.HelloWorldConfiguration : Load HelloWorld2019-11-24 21:25:02.712 INFO 13880 --- [ main] c.l.s.autoconfigure.entity.HelloWorld : hello world 2019! 去掉@EnableHelloWorld 注解或者条件注解修改为ConditionalOnSystemProperty(name = “user.name”, value = “lxt”)，分别重启，控制台输出如下，测试关闭情况成功 123456789101112131415***************************APPLICATION FAILED TO START***************************Description:Field helloWorld in com.lxt.springboot.autoconfigure.service.HelloWorldService required a bean of type 'com.lxt.springboot.autoconfigure.entity.HelloWorld' that could not be found.The injection point has the following annotations: - @org.springframework.beans.factory.annotation.Autowired(required=true)Action:Consider defining a bean of type 'com.lxt.springboot.autoconfigure.entity.HelloWorld' in your configuration. 五、源码 https://github.com/hdlxt/dive-in-spring-boot]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>自动装备</tag>
        <tag>核心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Spring Cloud 笔记和总结】八、使用 Sleuth和Zipkin进行服务跟踪]]></title>
    <url>%2F2019%2F11%2F13%2F2019-11-13-%E3%80%90Spring%20Cloud%20%E7%AC%94%E8%AE%B0%E5%92%8C%E6%80%BB%E7%BB%93%E3%80%91%E5%85%AB%E3%80%81%E4%BD%BF%E7%94%A8%20Sleuth%E5%92%8CZipkin%E8%BF%9B%E8%A1%8C%E6%9C%8D%E5%8A%A1%E8%B7%9F%E8%B8%AA%2F</url>
    <content type="text"><![CDATA[一、添加服务跟踪微服务项目zipkin-server父pom添加zipkin相关依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.lxt&lt;/groupId&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;modules&gt; &lt;module&gt;eureka-server&lt;/module&gt; &lt;module&gt;service-provider&lt;/module&gt; &lt;module&gt;service-provider1&lt;/module&gt; &lt;module&gt;service-consumer&lt;/module&gt; &lt;module&gt;service-consumer-hystrix&lt;/module&gt; &lt;module&gt;hystrix-dashboard-turbine&lt;/module&gt; &lt;module&gt;service-consumer-node01&lt;/module&gt; &lt;module&gt;service-consumer-node02&lt;/module&gt; &lt;module&gt;config-server&lt;/module&gt; &lt;module&gt;config-server1&lt;/module&gt; &lt;module&gt;config-client&lt;/module&gt; &lt;module&gt;zuul&lt;/module&gt; &lt;module&gt;consul-provider&lt;/module&gt; &lt;module&gt;consul-consumer&lt;/module&gt; &lt;module&gt;zipkin-server&lt;/module&gt; &lt;/modules&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;!-- &lt;spring-cloud.version&gt;Greenwich.RC1&lt;/spring-cloud.version&gt;--&gt; &lt;spring-cloud.version&gt;Greenwich.RELEASE&lt;/spring-cloud.version&gt; &lt;zipkin-version&gt;2.11.8&lt;/zipkin-version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt; &lt;artifactId&gt;zipkin-server&lt;/artifactId&gt; &lt;version&gt;$&#123;zipkin-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt; &lt;artifactId&gt;zipkin-autoconfigure-ui&lt;/artifactId&gt; &lt;version&gt;$&#123;zipkin-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; 本身pom文件依赖 1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--zipkin中包含spring-cloud-starter-sleuth,无需再次引入--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt; &lt;artifactId&gt;zipkin-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt; &lt;artifactId&gt;zipkin-autoconfigure-ui&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件 12345678910111213141516server: port: 9411spring: application: name: zipkin-servereureka: instance: hostname: localhost client: serviceUrl: defaultZone: http://localhost:8000/eureka/management: metrics: web: server: auto-time-requests: false 启动类添加@EnableZipkinServer123456789101112131415package com.lxt.zipkin;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import zipkin2.server.internal.EnableZipkinServer;@SpringBootApplication@EnableZipkinServerpublic class ZipkinServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZipkinServerApplication.class, args); &#125;&#125; 二、改造service-consumer、service-provider和zuul分别添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件分别添加 123456789#重点zipkin: # base-url:当你设置sleuth-cli收集信息后通过http传输到zinkin-server时，需要在这里配置 base-url: http://localhost:9411 enabled: truesleuth: sampler: #收集追踪信息的比率，如果是0.1则表示只记录10%的追踪数据，如果要全部追踪，设置为1（实际场景不推荐，因为会造成不小的性能消耗） probability: 1.0 注意：添加完毕依赖之后，刷新maven。运行测试 分别启动注册中心、网关、服务跟踪、服务提供和服务消费者 访问服务跟踪界面http://localhost:9411 浏览器访问http://localhost:8006/spring-cloud-pr/hello/1?token=2,查看服务跟踪界面三、相关 父模块介绍传送门 源码地址传送门]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Cloud</tag>
        <tag>微服务</tag>
        <tag>分布式</tag>
        <tag>Sleuth</tag>
        <tag>Zipkin</tag>
        <tag>服务跟踪</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Spring Cloud 笔记和总结】七、使用Zuul构建微服务网关.md]]></title>
    <url>%2F2019%2F11%2F10%2F2019-11-10-%E3%80%90Spring%20Cloud%20%E7%AC%94%E8%AE%B0%E5%92%8C%E6%80%BB%E7%BB%93%E3%80%91%E4%B8%83%E3%80%81%E4%BD%BF%E7%94%A8Zuul%E6%9E%84%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3%2F</url>
    <content type="text"><![CDATA[一、简单微服务网关搭建 maven依赖 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.lxt&lt;/groupId&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.lxt.gateaway&lt;/groupId&gt; &lt;artifactId&gt;zuul&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;zuul&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 配置文件 123456789spring: application: name: gateway-zuulserver: port: 8006eureka: client: serviceUrl: defaultZone: http://localhost:8000/eureka/ #注册中心eurka地址 启动类添加@EnableZuulProxy 123456789101112131415package com.lxt.gateaway.zuul;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.zuul.EnableZuulProxy;import org.springframework.context.annotation.Bean;@SpringBootApplication@EnableZuulProxypublic class ZuulApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulApplication.class, args); &#125;&#125; Spring Cloud Zuul默认配置说明 默认情况下，Zuul会代理所有注册到Eureka Server的微服务，并且Zuul的路由规则如下：http://ZUUL_HOST:ZUUL_PORT/微服务在Eureka上的serviceId/**会被转发到serviceId对应的微服务 eg:http://localhost:8006/spring-cloud-consumer/hello/lxt =&gt;http://spring-cloud-consumer/hello/lxt=&gt;http://localhost:9001/hello/lxt 也可手动配置指定 自定义微服务访问路径 123zuul: routes: spring-cloud-consumer-hystrix: /test/** 忽略指定微服务 12zuul: ignored-services: spring-cloud-consumer-hystrix,spring-cloud-consumer 同时指定微服务ServiceId和对应路径 12345zuul: routes: config-client: path: /lxt/** serviceId: spring-cloud-consumer-hystrix 等等… **启动测试** - 分别启动exureka-server、service-consumer、service-provider和zuul - 浏览器输入`http://localhost:8006/spring-cloud-consumer/hello/lxt` - 返回`hello lxt，this is first messge`，测试成功 #### 二、Zuul路由端点 - 由于 endpoints 中会包含很多敏感信息，除了 health 和 info 两个支持 web 访问外，其他的默认不支持 web 访问，需手动添加配置暴露`routes`路由端点 123456management: endpoints: web: exposure: # 2.x手动开启 这个是用来暴露 endpoints 的。由于 endpoints 中会包含很多敏感信息，除了 health 和 info 两个支持 web 访问外，其他的默认不支持 web 访问 include: routes - 浏览器`http://localhost:8006/actuator/routes`，返回如下 1234567// 20191121213009// http://localhost:8006/actuator/routes&#123; "/spring-cloud-consumer/**": "spring-cloud-consumer", "/spring-cloud-provider/**": "spring-cloud-provider"&#125; #### 三、Zuul中的Filter使用 **Zuul中默认实现的Filter** ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191121220713248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MjgzNzA5,size_16,color_FFFFFF,t_70) - PRE： 这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现身份验证、在集群中选择请求的微服务、记录调试信息等。 - ROUTING：这种过滤器将请求路由到微服务。这种过滤器用于构建发送给微服务的请求，并使用Apache HttpClient或Netfilx Ribbon请求微服务。 - POST：这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的HTTP Header、收集统计信息和指标、将响应从微服务发送给客户端等。 - ERROR：在其他阶段发生错误时执行该过滤器。 除了默认的过滤器类型，Zuul还允许我们创建自定义的过滤器类型。例如，我们可以定制一种STATIC类型的过滤器，直接在Zuul中生成响应，而不将请求转发到后端的微服务。 **自定义Filter示例** 必须包含`token`的参数才可访问，否则直接返回，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.lxt.gateaway.zuul;import com.netflix.zuul.ZuulFilter;import com.netflix.zuul.context.RequestContext;import com.netflix.zuul.exception.ZuulException;import org.apache.commons.lang.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import javax.servlet.http.HttpServletRequest;public class TokenFilter extends ZuulFilter &#123; private final Logger logger = LoggerFactory.getLogger(TokenFilter.class); @Override public String filterType() &#123; return "pre"; &#125; @Override public int filterOrder() &#123; return 0; &#125; @Override public boolean shouldFilter() &#123; return true; &#125; @Override public Object run() throws ZuulException &#123; RequestContext ctx = RequestContext.getCurrentContext(); HttpServletRequest request = ctx.getRequest(); logger.info("---&gt;&gt;&gt; TokenFilter &#123;&#125;,&#123;&#125;", request.getMethod(), request.getRequestURL().toString()); String token = request.getParameter("token");// 获取请求的参数 if (StringUtils.isNotBlank(token)) &#123; ctx.setSendZuulResponse(true); //对请求进行路由 ctx.setResponseStatusCode(200); ctx.set("isSuccess", true); return null; &#125; else &#123; ctx.setSendZuulResponse(false); //不对其进行路由 ctx.setResponseStatusCode(400); ctx.setResponseBody("token is empty"); ctx.set("isSuccess", false); return null; &#125; &#125;&#125; **注册Bean** 12345 @Beanpublic TokenFilter tokenFilter() &#123; return new TokenFilter();&#125; **运行测试** - 浏览器输入`http://localhost:8006/spring-cloud-consumer/hello/lxt`,返回`token is empty` - 浏览器输入`http://localhost:8006/spring-cloud-consumer/hello/lxt?token=2`,返回`hello lxt，this is first messge` #### 四、Zuul中的路由熔断和重试 ##### 路由熔断 **实现FallbackProvider接口，重写fallbackResponse方法** 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.lxt.gateaway.zuul;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.cloud.netflix.zuul.filters.route.FallbackProvider;import org.springframework.http.HttpHeaders;import org.springframework.http.HttpStatus;import org.springframework.http.MediaType;import org.springframework.http.client.ClientHttpResponse;import java.io.ByteArrayInputStream;import java.io.IOException;import java.io.InputStream;public class ProducerFallback implements FallbackProvider&#123; private final Logger logger = LoggerFactory.getLogger(FallbackProvider.class); //指定要处理的 service。 @Override public String getRoute() &#123; return "spring-cloud-provider"; &#125; @Override public ClientHttpResponse fallbackResponse(String route, Throwable cause) &#123; if (cause != null &amp;&amp; cause.getCause() != null) &#123; String reason = cause.getCause().getMessage(); logger.info("Excption &#123;&#125;",reason); &#125; return fallbackResponse(); &#125; public ClientHttpResponse fallbackResponse() &#123; return new ClientHttpResponse() &#123; @Override public HttpStatus getStatusCode() throws IOException &#123; return HttpStatus.OK; &#125; @Override public int getRawStatusCode() throws IOException &#123; return 200; &#125; @Override public String getStatusText() throws IOException &#123; return "OK"; &#125; @Override public void close() &#123; &#125; @Override public InputStream getBody() throws IOException &#123; return new ByteArrayInputStream("The service is unavailable.".getBytes()); &#125; @Override public HttpHeaders getHeaders() &#123; HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); return headers; &#125; &#125;; &#125;&#125; **注册bean** 1234@Beanpublic ProducerFallback producerFallback() &#123; return new ProducerFallback();&#125; **运行测试** - 再重启网关`zuul`,启动务提供者`service-provider1` - 浏览多次器输入`http://localhost:8006/spring-cloud-provider/foo?foo=lxt&amp;token=2` - 交替返回`hello lxt，this is first messge`和`hello lxt，this is two messge` - 关闭第二个服务提供者，继续刷新浏览器 - 交替返回`hello lxt，this is first messge`和`The service is unavailable.` ##### 路由重试 **添加依赖** 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt; &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;&lt;/dependency&gt; **修改配置文件** 12345zuul: retryable: true #是否开启重试功能ribbon: MaxAutoRetries: 2 #对当前服务的重试次数 MaxAutoRetriesNextServer: 0 #切换相同Server的次数 **修改service-provider1的hello方法如下** 12345678910@RequestMapping(value ="/hello", method = RequestMethod.GET)public String index(String name) &#123; logger.info("request two name is "+name); try&#123; Thread.sleep(1000000); &#125;catch ( Exception e)&#123; logger.error(" hello two error",e); &#125; return "hello "+name+"，this is two messge";&#125; **运行测试** - 重启网关`zuul`和`service-provider1` - 浏览器输入`http://localhost:8006/spring-cloud-provider/foo?foo=lxt&amp;token=2` - 返回`The service is unavailable.`时，查看控制如下： 1232019-11-21 22:38:31.049 INFO 11240 --- [nio-9002-exec-3] c.l.s.controller.HelloController : request two name is lxt2019-11-21 22:38:32.054 INFO 11240 --- [nio-9002-exec-4] c.l.s.controller.HelloController : request two name is lxt2019-11-21 22:38:33.060 INFO 11240 --- [nio-9002-exec-5] c.l.s.controller.HelloController : request two name is lxt - 打印了三次，重试了两次。 #### 五、相关 - 父模块介绍[`传送门`](https://blog.csdn.net/qq_25283709/article/category/9462287) - 源码地址[`传送门`](https://github.com/hdlxt/springcloud) - 参考 - http://www.ityouknow.com/spring-cloud.html]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Cloud</tag>
        <tag>微服务</tag>
        <tag>分布式</tag>
        <tag>Zuul</tag>
        <tag>网关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Spring Cloud 笔记和总结】六、Spring Cloud Config统一配置中心（Git+Spring Cloud Bus+RabbitMQ+Git WebHook）]]></title>
    <url>%2F2019%2F11%2F05%2F2019-11-05-%E3%80%90Spring%20Cloud%20%E7%AC%94%E8%AE%B0%E5%92%8C%E6%80%BB%E7%BB%93%E3%80%91%E5%85%AD%E3%80%81Spring%20Cloud%20Config%E7%BB%9F%E4%B8%80%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%EF%BC%88Git%2BSpring%20Cloud%20Bus%2BRabbitMQ%2BGit%20WebHook%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、简介 基于Spring Cloud Config实现统一配置中心，将配置文件存放于Git(GitHub)上，通过Spring Cloud Bus消息总线&amp;RabbitMQ消息中间件进行服务间消息通信。 涉及项目 exureka-server config-server config-client 整体架构图大致如下，使用GitHub Webhooks 触发配置中心刷新配置 上图来源：http://blog.didispace.com/springcloud7/ 二、配置中心服务端实现依赖 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.lxt&lt;/groupId&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.lxt&lt;/groupId&gt; &lt;artifactId&gt;config-server&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;config-server&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--集成Git Webhooks之后，使用/monitor即可实现配置更新，通知其他服务--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-monitor&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 配置文件 12345678910111213141516171819202122232425262728server: port: 8080spring: application: name: spring-cloud-config-server cloud: config: server: git: uri: https://github.com/hdlxt/springcloud # 配置git仓库的地址 search-paths: config-repo # git仓库地址下的相对地址，可以配置多个，用,分割。 username: # git仓库的账号 password: # git仓库的密码 rabbitmq: host: 111.231.xxxx.xx port: 5672 username: guest password: guesteureka: client: serviceUrl: defaultZone: http://localhost:8000/eureka/ #注册中心eurka地址management: endpoints: web: exposure: # 2.x手动开启 这个是用来暴露 endpoints 的。由于 endpoints 中会包含很多敏感信息，除了 health 和 info 两个支持 web 访问外，其他的默认不支持 web 访问 include: bus-refresh 主要内容 添加配置中心文件存放于github 配置rabbitmq连接信息 暴露bus-refresh github配置文件内容 仓库中的配置文件会被转换成 Web 接口，访问可以参照以下的规则： /{application}/{profile}[/{label}] /{application}-{profile}.yml /{label}/{application}-{profile}.yml /{application}-{profile}.properties /{label}/{application}-{profile}.properties 上面的 URL 会映射 {application}-{profile}.yml 对应的配置文件，其中 {label} 对应 Git 上不同的分支，默认为 master。 **启动类比较简单,声明是服务、配置中心服务端** 12345678910@EnableConfigServer@EnableDiscoveryClient@SpringBootApplicationpublic class ConfigServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigServerApplication.class, args); &#125;&#125; 到此配置中心服务端完毕。 #### 二、配置中心客户端实现 - 依赖 123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.lxt&lt;/groupId&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.lxt&lt;/groupId&gt; &lt;artifactId&gt;config-client&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;config-client&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; - 配置文件 - 关于` bootstrap.yml`和`application.yml` - bootstrap.yml（bootstrap.properties） 用来程序引导时执行，应用于更加早期配置信息读取，如可以使用来配置application.yml中使用到参数等 - application.yml（application.properties) 应用程序特有配置信息，可以用来配置后续各个模块中需使用的公共参数等。 - bootstrap.yml 先于 application.yml 加载 - bootstrap.yml 1234567891011121314151617server: port: 8003spring: cloud: config: name: lxt-config profile: dev label: master discovery: #开启Config服务发现支持 enabled: true #指定server端的name,也就是server端spring.application.name的值 service-id: spring-cloud-config-servereureka: client: service-url: defaultZone: http://localhost:8000/eureka/ - application.yml 123456789101112131415161718spring: application: name: spring-cloud-config-client cloud: bus: trace: # 开启消息跟踪事件 enabled: true rabbitmq: host: 111.231.29.249 port: 5672 username: guest password: guestmanagement: endpoints: web: exposure: include: refresh - 主要代码 - 核心 - @EnableDiscoveryClient - @RefreshScope:使用该注解的类，会在接到SpringCloud配置中心配置刷新的时候，自动将新的配置更新到该类对应的字段中 - 启动类 12345678910@EnableDiscoveryClient@SpringBootApplicationpublic class ConfigClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigClientApplication.class, args); &#125;&#125; - 测试 12345678910111213141516171819/** * @author lxt * @Copy Right Information: lxt * @Project: spring cloud * @CreateDate: 2018/12/16 20:04 * @history Sr Date Modified By Why &amp; What is modified * 1.2018/12/16 lxt &amp; new */@RestController@RefreshScope // 使用该注解的类，会在接到SpringCloud配置中心配置刷新的时候，自动将新的配置更新到该类对应的字段中public class HelloController &#123; @Value("$&#123;lxt.hello&#125;") private String hello; @RequestMapping("/hello") public String from() &#123; return this.hello; &#125;&#125; #### 三、整合 **以安装包或者docker方式安装RabbitMQ，启动**![在这里插入图片描述](https://img-blog.csdnimg.cn/20191117213514487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MjgzNzA5,size_16,color_FFFFFF,t_70) **配置GitHub Webhooks** - （可选，云服务器可跳过）内网穿透工具下载[natapp](#https://natapp.cn/)安装和配置（有免费通道），目的可给本机电脑映射一个外网域名，用于配置Webhooks ![在这里插入图片描述](https://img-blog.csdnimg.cn/2019111721323258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MjgzNzA5,size_16,color_FFFFFF,t_70) - 配置Webhooks，配置中心服务端需引入`spring-cloud-config-monitor`依赖 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191117214212673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MjgzNzA5,size_16,color_FFFFFF,t_70) #### 四、测试 - 分别启动注册中心、配置中心服务端 - 启动多个客户端 - 可通过打jar包形式启动 - 也可通过idea添加启动类，指定不同端口启动 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191117213813171.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MjgzNzA5,size_16,color_FFFFFF,t_70) - 修改配置文件，push到github上触发回调`http://t23b4j.natappfree.cc/monitor`,通知配置中心服务端更新配置，服务端以mq形式通过消息总线通知客户端更新配置。 #### 五、相关 - 父模块介绍[`传送门`](https://blog.csdn.net/qq_25283709/article/category/9462287) - 源码地址[`传送门`](https://github.com/hdlxt/springcloud) - 参考 - http://www.ityouknow.com/spring-cloud.html]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Cloud</tag>
        <tag>微服务</tag>
        <tag>分布式</tag>
        <tag>统一配置中心</tag>
        <tag>Spring Cloud Bus</tag>
        <tag>RabbitMQ</tag>
        <tag>Git WebHook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Spring Cloud 笔记和总结】五、 Hystrix Dashboard和Turbine监控]]></title>
    <url>%2F2019%2F11%2F03%2F2019-11-03-%E3%80%90Spring%20Cloud%20%E7%AC%94%E8%AE%B0%E5%92%8C%E6%80%BB%E7%BB%93%E3%80%91%E4%BA%94%E3%80%81%20Hystrix%20Dashboard%E5%92%8CTurbine%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[一、Hystrix Dashboard监控 涉及项目 service-consumer-hystrix =&gt; 基于service-consumer修改 依赖 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.lxt&lt;/groupId&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.lxt&lt;/groupId&gt; &lt;artifactId&gt;service-consumer-hystrix&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;service-consumer-hystrix&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; - 配置文件 123456789101112spring: application: name: spring-cloud-consumer-hystrixserver: port: 9004feign: hystrix: enabled: trueeureka: client: service-url: defaultZone: http://localhost:8000/eureka/ - 启动类添加注解,注意`getServlet()`方法，用于解决spring cloud2 hystrix没有hystrix.stream路径 12345678910111213141516171819202122232425262728293031323334353637package com.lxt.springcloudconsumerhystrix; import com.netflix.hystrix.contrib.metrics.eventstream.HystrixMetricsStreamServlet;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;import org.springframework.cloud.openfeign.EnableFeignClients;import org.springframework.context.annotation.Bean;@SpringBootApplication@EnableDiscoveryClient@EnableFeignClients@EnableHystrixDashboard@EnableCircuitBreakerpublic class SpringCloudConsumerHystrixApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringCloudConsumerHystrixApplication.class, args); &#125; /** * 解决：找不到/hystrix.stream 报错：=&gt;Unable to connect to Command Metric Stream. * @return */ @Bean public ServletRegistrationBean getServlet() &#123; HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet(); ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet); registrationBean.setLoadOnStartup(1); registrationBean.addUrlMappings("/hystrix.stream"); registrationBean.setName("HystrixMetricsStreamServlet"); return registrationBean; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869- 启动项目，浏览器输入`http://localhost:9004/hystrix`,如下：![在这里插入图片描述](https://img-blog.csdnimg.cn/20191117123726133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MjgzNzA5,size_16,color_FFFFFF,t_70) - 监控默认集群：http://turbine-hostname:port/turbine.stream - 监控指定集群：http://turbine-hostname:port/turbine.stream?cluster=[clusterName] - 监控的那个应用：http://hystrix-app:port/hystrix.stream- 输入`http://localhost:9004/hystrix.stream `进入监控页面，此时页面显示`Loading`![在这里插入图片描述](https://img-blog.csdnimg.cn/20191117124843621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MjgzNzA5,size_16,color_FFFFFF,t_70)![在这里插入图片描述](https://img-blog.csdnimg.cn/20191117125004752.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MjgzNzA5,size_16,color_FFFFFF,t_70)- 浏览器访问`http://localhost:9004/hello/lxt`之后，监控页面如下![在这里插入图片描述](https://img-blog.csdnimg.cn/20191117124832598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MjgzNzA5,size_16,color_FFFFFF,t_70)- 图中参数解释如下界面解读![在这里插入图片描述](https://img-blog.csdnimg.cn/2019111712515840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MjgzNzA5,size_16,color_FFFFFF,t_70)实心圆：它有颜色和大小之分，分别代表实例的监控程度和流量大小。如上图所示，它的健康度从绿色、黄色、橙色、红色递减。通过该实心圆的展示，我们就可以在大量的实例中快速的发现故障实例和高压力实例。曲线：用来记录 2 分钟内流量的相对变化，我们可以通过它来观察到流量的上升和下降趋势。其他一些数量指标如下图所示![在这里插入图片描述](https://img-blog.csdnimg.cn/20191117125216734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MjgzNzA5,size_16,color_FFFFFF,t_70)- 测试成功#### 二、Turbine集群监控 - 涉及项目 - hystrix-dashboard-turbine - service-consumer-node01 =&gt; 基于service-consumer-hystrix - service-consumer-node02 =&gt; 基于service-consumer-hystrix - **hystrix-dashboard-turbine项目添加**- 依赖 ```bash &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.lxt&lt;/groupId&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.lxt&lt;/groupId&gt; &lt;artifactId&gt;hystrix-dashboard-turbine&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;hystrix-dashboard-turbine&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-turbine&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; - 配置文件 12345678910111213141516171819202122spring: application: name: turbine-clientserver: port: 9009turbine: # 需要监控的应用名称，默认逗号隔开，内部使用Stringutils.commaDelimitedListToStringArray分割 app-config: hystrix-client1,hystrix-client2 aggregator: cluster-config: default # 集群名称 cluster-name-expression: new String("default") combine-host-port: trueeureka: client: service-url: defaultZone: http://localhost:8000/eureka/ instance: # 启用ip配置 这样在注册中心列表中看见的是以ip+端口呈现的 prefer-ip-address: true # 实例名称 最后呈现地址：ip:2000 instance-id: $&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125; - 启动类 1234567891011121314151617181920212223242526272829303132package com.lxt.hystrixdashboardturbine;import com.netflix.hystrix.contrib.metrics.eventstream.HystrixMetricsStreamServlet;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;import org.springframework.cloud.netflix.turbine.EnableTurbine;import org.springframework.context.annotation.Bean;@SpringBootApplication@EnableHystrixDashboard@EnableTurbinepublic class HystrixDashboardTurbineApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HystrixDashboardTurbineApplication.class, args); &#125; /** * @return */ @Bean public ServletRegistrationBean getServlet() &#123; HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet(); ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet); registrationBean.setLoadOnStartup(1); registrationBean.addUrlMappings("/actuator/hystrix.stream"); registrationBean.setName("HystrixMetricsStreamServlet"); return registrationBean; &#125;&#125; **service-consumer-node01/02的依赖、代码和service-consumer-hystrix一样，区别在于一个配置，如下** - 配置文件,关键点`management.endpoints.web.exposure.include：hystrix.stream` 12345678910111213141516171819spring: application: name: hystrix-client1server: port: 9005feign: hystrix: enabled: truemanagement: endpoints: web: exposure: # 2.x手动开启 这个是用来暴露 endpoints 的。由于 endpoints 中会包含很多敏感信息，除了 health 和 info 两个支持 web 访问外，其他的默认不支持 web 访问 include: hystrix.streameureka: client: service-url: defaultZone: http://localhost:8000/eureka/ **测试** - 分别启动注册中心、服务提供者、Turbine监控和两个服务消费者(service-consumer-node01/02) ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191117143021668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MjgzNzA5,size_16,color_FFFFFF,t_70) **TURBINE-CLIENT再注册中心显示ip:port** - 浏览器访问`http://localhost:9009/hystrix`,监控默认集群 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191117143330676.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MjgzNzA5,size_16,color_FFFFFF,t_70) ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191117143406677.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MjgzNzA5,size_16,color_FFFFFF,t_70) - 浏览器访问`http://localhost:9005/hello/lxt`和`http://localhost:9006/hello/lxt` ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191117143526476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MjgzNzA5,size_16,color_FFFFFF,t_70) - 测试成功 #### 三、相关 - 父模块介绍[`传送门`](https://blog.csdn.net/qq_25283709/article/category/9462287) - 源码地址[`传送门`](https://github.com/hdlxt/springcloud) - 参考 - https://www.cnblogs.com/carrychan/p/9529418.html - http://www.ityouknow.com/spring-cloud.html]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Cloud</tag>
        <tag>微服务</tag>
        <tag>分布式</tag>
        <tag>Hystrix Dashboar</tag>
        <tag>Turbine</tag>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Spring Cloud 笔记和总结】四、熔断器Hystrix简单实现]]></title>
    <url>%2F2019%2F10%2F25%2F2019-10-25-%E3%80%90Spring%20Cloud%20%E7%AC%94%E8%AE%B0%E5%92%8C%E6%80%BB%E7%BB%93%E3%80%91%E5%9B%9B%E3%80%81%E7%86%94%E6%96%AD%E5%99%A8Hystrix%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[一、简单实现 基于上文服务消费者（service-consumer）代码。 修改配置文件，添加：feign.hystrix.enable:true如下： 123456789101112spring: application: name: spring-cloud-consumerserver: port: 9001eureka: client: serviceUrl: defaultZone: http://localhost:8000/eureka/feign: hystrix: enabled: true - 添加容错回调类 123456789101112131415161718192021package com.lxt.serviceconsumer.hystrix;import com.lxt.serviceconsumer.dao.fegin.HelloFegin;import org.springframework.stereotype.Component;import org.springframework.web.bind.annotation.RequestParam;/** * @author lxt * @Copy Right Information: lxt * @Project: spring cloud * @CreateDate: 2018/12/16 15:58 * @history Sr Date Modified By Why &amp; What is modified * 1.2018/12/16 lxt &amp; new */@Componentpublic class HelloFeginHystrix implements HelloFegin &#123; @Override public String hello(@RequestParam(value = "name") String name) &#123; return "hello " +name+", this messge send failed "; &#125;&#125; - 修改`HelloFegin`添加回调`fallback`属性 1@FeignClient(name= "spring-cloud-provider",fallback = HelloFeginHystrix.class) - 测试 - 分别启动注册中心、服务提供者和服务消费者 - 浏览器访问`localhost:9001/hello/lxt`,返回`hello lxt，this is first messge` - 停止服务提供者，再次访问 - 返回`hello lxt，this messge send failed` - 测试成功 #### 二、相关 - 父模块介绍[`传送门`](https://blog.csdn.net/qq_25283709/article/category/9462287) - 源码地址[`传送门`](https://github.com/hdlxt/springcloud) - 参考 - https://www.cnblogs.com/carrychan/p/9529418.html]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Cloud</tag>
        <tag>微服务</tag>
        <tag>分布式</tag>
        <tag>Hystrix</tag>
        <tag>熔断器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Spring Cloud 笔记和总结】三、服务提供与消费和实现客户端负载均衡]]></title>
    <url>%2F2019%2F10%2F18%2F2019-10-18-%E3%80%90Spring%20Cloud%20%E7%AC%94%E8%AE%B0%E5%92%8C%E6%80%BB%E7%BB%93%E3%80%91%E4%B8%89%E3%80%81%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E4%B8%8E%E6%B6%88%E8%B4%B9%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%2F</url>
    <content type="text"><![CDATA[一、简介注册中心Eureka架构图如下：分别是注册中心（Eureka）、服务提供（Service Provider）和服务消费（Service Consumer），后两者均为注册到注册中心的服务，因调用关系不同而身份不同，不同的业务场景下身份可能会互换。 二、主要内容1、服务提供者结构如下：HelloController添加注解@RestController,核心代码如下 12345678@RequestMapping(value = "/hello",method = RequestMethod.GET)public String index(String name) &#123; return "hello "+name+"，this is first messge";&#125;@RequestMapping(value = "/foo")public String foo(String foo) &#123; return "hello "+foo+"，this is first messge";&#125; application.yml配置文件 123456789spring: application: name: spring-cloud-providerserver: port: 9000eureka: client: serviceUrl: defaultZone: http://localhost:8000/eureka/ pom.xml文件 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.lxt&lt;/groupId&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.lxt&lt;/groupId&gt; &lt;artifactId&gt;service-provider&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;service-provider&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2、服务消费者结构如下，暂时忽略hystrix包HelloRemote代码 12345678910111213141516171819@Componentpublic class HelloRest &#123; @Autowired private RestTemplate restTemplate; public String hello(String name)&#123; String response = restTemplate.getForObject("http://spring-cloud-provider/foo?foo="+name,String.class); return response; &#125; @Bean public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; ConsumerController核心代码 1234567891011121314@RestControllerpublic class ConsumerController &#123; @Autowired private HelloRest helloRest; @RequestMapping("/hello/&#123;name&#125;") public String index(@PathVariable("name") String name) &#123; return helloRest.hello(name); &#125; @RequestMapping("/test") public String test() &#123; return "test success!"; &#125;&#125; application.yml配文件 123456789spring: application: name: spring-cloud-consumerserver: port: 9001eureka: client: serviceUrl: defaultZone: http://localhost:8000/eureka/ pom.xml文件 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.lxt&lt;/groupId&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.lxt&lt;/groupId&gt; &lt;artifactId&gt;service-consumer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;service-consumer&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 三、结果演示 分别启动注册中心、服务提供者和服务消费者，如下图 调用服务消费者测试- 浏览器输入`http://localhost:9001/hello/lxt` - 返回`hello lxt，this is first messge`，测试成功 四、整合Feign实现负载均衡简介 Fegin是Netfix开发的声明式、模板化的HTTP客户端，Spring Cloud 对Fegin进行了增强，使Fegin支持了Spring MVC注解，并整合了Ribbon和Eureka，从而让Fegin的使用更加方便。 Ribbon是基于Netfix发布的客户端负载均衡器，默认提供了轮询、随机等负载均衡算法，开发者也可以自定义负载均衡算法。 Eureka Server 和 Fegin整合使用大致架构如下实现负载均衡 依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 启动类添加注解@EnableFeignClients启用feign进行远程调用 12345678910@SpringBootApplication@EnableDiscoveryClient//启用服务注册与发现@EnableFeignClients//启用feign进行远程调用public class ServiceConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ServiceConsumerApplication.class, args); &#125;&#125; 使用@FeignClient实现负载均衡 1234567// name:配置服务提供者名称，用于从注册中心获取服务提供者信息@FeignClient(name= "spring-cloud-provider")public interface HelloFegin &#123; @RequestMapping(value = "/hello") public String hello(@RequestParam(value = "name") String name);&#125; 复制service-provider,重命名service-provider1 修改配置文件端口为9002 修改HelloController.index返回值为&quot;hello &quot;+name+&quot;，this is two messge&quot; 如下图： 注册中心 多次测试http://localhost:9001/hello/lxt分别返回hello lxt，this is first messge和hello lxt，this is two messge五、相关 父模块介绍传送门 源码地址传送门]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Cloud</tag>
        <tag>微服务</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Spring Cloud 笔记和总结】二、注册中心Eureka]]></title>
    <url>%2F2019%2F10%2F07%2F2019-10-07-%E3%80%90Spring%20Cloud%20%E7%AC%94%E8%AE%B0%E5%92%8C%E6%80%BB%E7%BB%93%E3%80%91%E4%BA%8C%E3%80%81%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83Eureka%2F</url>
    <content type="text"><![CDATA[一、关于注册中心主要功能如下 服务注册表：记录分布式架构中所有服务和服务地址的映射关系，用于服务直接相互调用 服务注册与发现：服务启动时将自己的信息注册到注册中心；服务直接相互调用时从注册中心获取目标服务信息 服务健康检查 ：使用一定机制检查注册中心的服务是否正常，如果长时间无法访问，则将其移除 常见注册中心 Eureka Consul Zookeeper Nacos…本文以Eureka为例，后续会更新其他注册中心 二、主要内容结构如下配置文件application.yml如下 12345678910111213spring: application: name: spring-cloud-eureka #服务名称server: port: 8000eureka: instance: hostname: localhost client: register-with-eureka: false #表示是否将自己注册到Eureka Server，默认为true。 fetch-registry: false #表示是否从Eureka Server获取注册信息，默认为true。 serviceUrl: defaultZone: http://localhost:8000/eureka #服务地址，多个可用逗号【,】分隔 pom文件如下 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.lxt&lt;/groupId&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;groupId&gt;com.lxt&lt;/groupId&gt; &lt;artifactId&gt;exureka-server&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;exureka-server&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 运行结果如下图所示，注册中心目前无服务注册 三、集群高可用C:\Windows\System32\drivers\etc\host文件添加映射 123127.0.0.1 center127.0.0.1 center1127.0.0.1 center2 使用yml配置文件连接符---添加三个集群的节点center、center1、center2,修改后配置文件如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152spring: application: name: spring-cloud-eureka #服务名称---server: port: 8000eureka: instance: hostname: localhost client: register-with-eureka: false #表示是否将自己注册到Eureka Server，默认为true。 fetch-registry: false #表示是否从Eureka Server获取注册信息，默认为true。 serviceUrl: defaultZone: http://localhost:8000/eureka/ #服务地址，多个可用逗号【,】分隔---spring: profiles: centerserver: port: 8000eureka: instance: hostname: center client: #register-with-eureka: false #表示是否将自己注册到Eureka Server，默认为true。 ##fetch-registry: false #表示是否从Eureka Server获取注册信息，默认为true。 serviceUrl: defaultZone: http://center1:8100/eureka/,http://center2:8200/eureka/ #服务地址，多个可用逗号【,】分隔---spring: profiles: center1server: port: 8100eureka: instance: hostname: center1 client: serviceUrl: defaultZone: http://center:8000/eureka/,http://center2:8200/eureka/ #服务地址，多个可用逗号【,】分隔---spring: profiles: center2server: port: 8200eureka: instance: hostname: center2 client: serviceUrl: defaultZone: http://center:8000/eureka/,http://center1:8100/eureka/ #服务地址，多个可用逗号【,】分隔--- 启动： mvn package 打成jar包 cmd 切入到jar所在目录 分别运行： 123java -jar spring-cloud-eureka-0.0.1-SNAPSHOT.jar --spring.profiles.active=centerjava -jar spring-cloud-eureka-0.0.1-SNAPSHOT.jar --spring.profiles.active=center1java -jar spring-cloud-eureka-0.0.1-SNAPSHOT.jar --spring.profiles.active=center2 浏览器查看，集群搭建成功 四、相关 父模块介绍传送门 源码地址传送门]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Cloud</tag>
        <tag>微服务</tag>
        <tag>分布式</tag>
        <tag>注册中心</tag>
        <tag>Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Spring Cloud 笔记和总结】一、写在开头，内容简述（Spring Boot 2.1.1&Spring Cloud Greenwich.RELEASE）]]></title>
    <url>%2F2019%2F10%2F01%2F2019-10-01-%E3%80%90Spring%20Cloud%20%E7%AC%94%E8%AE%B0%E5%92%8C%E6%80%BB%E7%BB%93%E3%80%91%E4%B8%80%E3%80%81%E5%86%99%E5%9C%A8%E5%BC%80%E5%A4%B4%EF%BC%8C%E5%86%85%E5%AE%B9%E7%AE%80%E8%BF%B0%EF%BC%88Spring%20Boot%202.1.1%26Spring%20Cloud%20Greenwich.RELEASE%EF%BC%89%20-%20%E5%89%AF%E6%9C%AC%20(2)%2F</url>
    <content type="text"><![CDATA[今年年初参考大佬的博客初步学习和敲了一遍Spring Cloud，此系列博客，一方面是回顾之前的学习过程，另一方面要巩固和深入学习微服务相关知识。 之前的源码地址传送门 版本 jdk1.8 Spring Boot ：2.1.1.RELEASE Spring Cloud ： Greenwich.RELEASE 计划 以博客笔记形式回顾一遍,以代码实现为主 更换其中部分技术 项目maven多模块，如下图所示 所有子模块都继承父模块spring cloud依赖，如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.lxt&lt;/groupId&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;modules&gt; &lt;module&gt;eureka-server&lt;/module&gt; &lt;module&gt;service-provider&lt;/module&gt; &lt;module&gt;service-provider1&lt;/module&gt; &lt;module&gt;service-consumer&lt;/module&gt; &lt;module&gt;service-consumer-hystrix&lt;/module&gt; &lt;module&gt;hystrix-dashboard-turbine&lt;/module&gt; &lt;module&gt;service-consumer-node01&lt;/module&gt; &lt;module&gt;service-consumer-node02&lt;/module&gt; &lt;module&gt;config-server&lt;/module&gt; &lt;module&gt;config-server1&lt;/module&gt; &lt;module&gt;config-client&lt;/module&gt; &lt;module&gt;zuul&lt;/module&gt; &lt;module&gt;consul-provider&lt;/module&gt; &lt;module&gt;consul-consumer&lt;/module&gt; &lt;module&gt;zipkin-server&lt;/module&gt; &lt;/modules&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;!-- &lt;spring-cloud.version&gt;Greenwich.RC1&lt;/spring-cloud.version&gt;--&gt; &lt;spring-cloud.version&gt;Greenwich.RELEASE&lt;/spring-cloud.version&gt; &lt;zipkin-version&gt;2.11.8&lt;/zipkin-version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt; &lt;artifactId&gt;zipkin-server&lt;/artifactId&gt; &lt;version&gt;$&#123;zipkin-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt; &lt;artifactId&gt;zipkin-autoconfigure-ui&lt;/artifactId&gt; &lt;version&gt;$&#123;zipkin-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; 参考 《Spring Cloud和Docker微服务架构实战》 http://www.ityouknow.com/spring-cloud.html]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Cloud</tag>
        <tag>微服务</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Spring Cloud 笔记和总结】一、写在开头，内容简述（Spring Boot 2.1.1&Spring Cloud Greenwich.RELEASE）]]></title>
    <url>%2F2019%2F10%2F01%2F2019-11-13-%E3%80%90Spring%20Cloud%20%E7%AC%94%E8%AE%B0%E5%92%8C%E6%80%BB%E7%BB%93%E3%80%91%E4%B8%80%E3%80%81%E5%86%99%E5%9C%A8%E5%BC%80%E5%A4%B4%EF%BC%8C%E5%86%85%E5%AE%B9%E7%AE%80%E8%BF%B0%EF%BC%88Spring%20Boot%202.1.1%26Spring%20Cloud%20Greenwich.RELEASE%EF%BC%89%2F</url>
    <content type="text"><![CDATA[今年年初参考大佬的博客初步学习和敲了一遍Spring Cloud，此系列博客，一方面是回顾之前的学习过程，另一方面要巩固和深入学习微服务相关知识。 之前的源码地址传送门 版本 jdk1.8 Spring Boot ：2.1.1.RELEASE Spring Cloud ： Greenwich.RELEASE 计划 以博客笔记形式回顾一遍,以代码实现为主 更换其中部分技术 项目maven多模块，如下图所示 所有子模块都继承父模块spring cloud依赖，如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.lxt&lt;/groupId&gt; &lt;artifactId&gt;springcloud&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;modules&gt; &lt;module&gt;eureka-server&lt;/module&gt; &lt;module&gt;service-provider&lt;/module&gt; &lt;module&gt;service-provider1&lt;/module&gt; &lt;module&gt;service-consumer&lt;/module&gt; &lt;module&gt;service-consumer-hystrix&lt;/module&gt; &lt;module&gt;hystrix-dashboard-turbine&lt;/module&gt; &lt;module&gt;service-consumer-node01&lt;/module&gt; &lt;module&gt;service-consumer-node02&lt;/module&gt; &lt;module&gt;config-server&lt;/module&gt; &lt;module&gt;config-server1&lt;/module&gt; &lt;module&gt;config-client&lt;/module&gt; &lt;module&gt;zuul&lt;/module&gt; &lt;module&gt;consul-provider&lt;/module&gt; &lt;module&gt;consul-consumer&lt;/module&gt; &lt;module&gt;zipkin-server&lt;/module&gt; &lt;/modules&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;!-- &lt;spring-cloud.version&gt;Greenwich.RC1&lt;/spring-cloud.version&gt;--&gt; &lt;spring-cloud.version&gt;Greenwich.RELEASE&lt;/spring-cloud.version&gt; &lt;zipkin-version&gt;2.11.8&lt;/zipkin-version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt; &lt;artifactId&gt;zipkin-server&lt;/artifactId&gt; &lt;version&gt;$&#123;zipkin-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt; &lt;artifactId&gt;zipkin-autoconfigure-ui&lt;/artifactId&gt; &lt;version&gt;$&#123;zipkin-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; 参考 《Spring Cloud和Docker微服务架构实战》 http://www.ityouknow.com/spring-cloud.html]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Spring Cloud</tag>
        <tag>微服务</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot & 极验验证滑动验证码]]></title>
    <url>%2F2019%2F03%2F04%2F2019-03-04-Spring%20Boot%20%26%20%E6%9E%81%E9%AA%8C%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[基于极验验证官网 java版gt3-java-sdk改编,使用Spring Boot 整合的极验滑动验证，包含form表单登录和ajax登录两种情况。 目录 注册账户获取ID和KEY Demo源码说明 Demo演示 源码地址 注册账户获取ID和KEY 1.进入官网注册账户 2.登录后台选择行为认证 3.增加认证 4.输入信息 5.获取ID和KEY Demo源码说明 1.Demo结构 2.关键代码说明 sdk包下类和gt.js为极验验证官方提供 GeetestConfig.java：ID和KEY配置位置 12345678910111213141516// 填入自己的captcha_id和private_keyprivate static final String geetest_id = "978b73ea94b4393026524553045ed2ab";private static final String geetest_key = "7cd60bfef0a65a78ace8ba085aad023d";private static final boolean newfailback = true;public static final String getGeetest_id() &#123; return geetest_id;&#125;public static final String getGeetest_key() &#123; return geetest_key;&#125;public static final boolean isnewfailback() &#123; return newfailback;&#125; GeeTestUtil.java：自定义极验验证工具类，对用户操作结果进行验证 123456789101112131415161718192021222324252627282930313233/** * * @param httpSession * @param challenge * @param validate * @param seccode * @return */ public static boolean validate(HttpSession httpSession,String challenge, String validate, String seccode)&#123; GeetestLib gtSdk = new GeetestLib(GeetestConfig.getGeetest_id(), GeetestConfig.getGeetest_key(), GeetestConfig.isnewfailback()); //从session中获取gt-server状态 int gt_server_status_code = (Integer) httpSession.getAttribute(gtSdk.gtServerStatusSessionKey); //从session中获取userid String userid = (String)httpSession.getAttribute("userid"); //自定义参数,可选择添加 HashMap&lt;String, String&gt; param = new HashMap&lt;String, String&gt;(); param.put("user_id", userid); //网站用户id param.put("client_type", "web"); //web:电脑上的浏览器；h5:手机上的浏览器，包括移动应用内完全内置的web_view；native：通过原生SDK植入APP应用的方式 param.put("ip_address", "127.0.0.1"); //传输用户请求验证时所携带的IP int gtResult = RESULT_FAIL; boolean flag = false; if (gt_server_status_code == GT_SERVER_STATUS_CODE_OK) &#123; //gt-server正常，向gt-server进行二次验证 gtResult = gtSdk.enhencedValidateRequest(challenge, validate, seccode, param); &#125; else &#123; // gt-server非正常情况下，进行failback模式验证 System.out.println("failback:use your own server captcha validate"); gtResult = gtSdk.failbackValidateRequest(challenge, validate, seccode); System.out.println(gtResult); &#125; return gtResult == RESULT_OK; &#125; GeetTestController.java：注册验证码，获取流水号，加载验证码时调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 验证1初始化 * @return */ @ResponseBody @GetMapping("register1") public String register1()&#123; GeetestLib gtSdk = new GeetestLib(GeetestConfig.getGeetest_id(), GeetestConfig.getGeetest_key(), GeetestConfig.isnewfailback()); String resStr = "&#123;&#125;"; String userid = "test"; //自定义参数,可选择添加 HashMap&lt;String, String&gt; param = new HashMap&lt;String, String&gt;(); param.put("user_id", userid); //网站用户id param.put("client_type", "web"); //web:电脑上的浏览器；h5:手机上的浏览器，包括移动应用内完全内置的web_view；native：通过原生SDK植入APP应用的方式 param.put("ip_address", "127.0.0.1"); //传输用户请求验证时所携带的IP //进行验证预处理 int gtServerStatus = gtSdk.preProcess(param); //将服务器状态设置到session中 httpSession.setAttribute(gtSdk.gtServerStatusSessionKey, gtServerStatus); //将userid设置到session中 httpSession.setAttribute("userid", userid); resStr = gtSdk.getResponseStr(); return resStr; &#125; /** * 验证2 二次验证 * @return */ @ResponseBody @GetMapping("register2") public String register2()&#123; GeetestLib gtSdk = new GeetestLib(GeetestConfig.getGeetest_id(), GeetestConfig.getGeetest_key(), GeetestConfig.isnewfailback()); String resStr = "&#123;&#125;"; //自定义userid String userid = "test"; //自定义参数,可选择添加 HashMap&lt;String, String&gt; param = new HashMap&lt;String, String&gt;(); param.put("user_id", userid); //网站用户id param.put("client_type", "web"); //web:电脑上的浏览器；h5:手机上的浏览器，包括移动应用内完全内置的web_view；native：通过原生SDK植入APP应用的方式 param.put("ip_address", "127.0.0.1"); //传输用户请求验证时所携带的IP //进行验证预处理 int gtServerStatus = gtSdk.preProcess(param); //将服务器状态设置到session中 httpSession.setAttribute(gtSdk.gtServerStatusSessionKey, gtServerStatus); //将userid设置到session中 httpSession.setAttribute("userid", userid); resStr = gtSdk.getResponseStr(); return resStr; &#125; LoginController.java：登录验证类，控制验证码和账号密码验证结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** *模拟表单登录 * @param model * @param geetest_challenge * @param geetest_validate * @param geetest_seccode * @param username1 * @param password1 * @return */ @RequestMapping("/loginForm") public String loginForm(Model model,String geetest_challenge, String geetest_validate, String geetest_seccode ,String username1, String password1)&#123; if(!GeeTestUtil.validate(httpSession,geetest_challenge,geetest_validate,geetest_seccode))&#123; model.addAttribute("result","验证失败!!!"); return "result"; &#125; if("admin1".equals(username1) &amp;&amp; "admin1".equals(password1))&#123; model.addAttribute("result","登录成功!!!"); &#125;else&#123; model.addAttribute("result","登录失败!!!"); &#125; return "result"; &#125; /** * 模拟AJAX登录 * @param geetest_challenge * @param geetest_validate * @param geetest_seccode * @param username2 * @param password2 * @return */ @ResponseBody @RequestMapping("/loginAJAX") public String loginAJAX(String geetest_challenge, String geetest_validate, String geetest_seccode ,String username2, String password2)&#123; if(!GeeTestUtil.validate(httpSession,geetest_challenge,geetest_validate,geetest_seccode))&#123; return "验证失败!!!"; &#125; if("admin2".equals(username2) &amp;&amp; "admin2".equals(password2))&#123; return "登录成功!!!"; &#125;else&#123; return "登录失败!!!"; &#125; &#125; login.html：登录界面和验证码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145&lt;form action="/login/loginForm" method="post" target="_blank"&gt; &lt;h2&gt;大图点击Demo，使用表单进行二次验证&lt;/h2&gt; &lt;br&gt; &lt;div&gt; &lt;label for="username1"&gt;用户名：&lt;/label&gt; &lt;input class="inp" id="username1" name="username1" type="text" value="admin1"&gt; &lt;/div&gt; &lt;br&gt; &lt;div&gt; &lt;label for="password1"&gt;密码：&lt;/label&gt; &lt;input class="inp" id="password1" name="password1" type="password" value="admin1"&gt; &lt;/div&gt; &lt;br&gt; &lt;div&gt; &lt;label&gt;完成验证：&lt;/label&gt; &lt;div id="captcha1"&gt; &lt;p id="wait1" class="show"&gt;正在加载验证码......&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;br&gt; &lt;p id="notice1" class="hide"&gt;请先完成验证&lt;/p&gt; &lt;input class="btn" id="submit1" type="submit" value="提交"&gt;&lt;/form&gt;&lt;br&gt;&lt;br&gt;&lt;hr&gt;&lt;form&gt; &lt;h2&gt;滑动demo，使用ajax进行二次验证&lt;/h2&gt; &lt;br&gt; &lt;div&gt; &lt;label for="username2"&gt;用户名：&lt;/label&gt; &lt;input class="inp" id="username2" type="text" value="admin2"&gt; &lt;/div&gt; &lt;br&gt; &lt;div&gt; &lt;label for="password2"&gt;密码：&lt;/label&gt; &lt;input class="inp" id="password2" type="password" value="admin2"&gt; &lt;/div&gt; &lt;br&gt; &lt;div&gt; &lt;label&gt;完成验证：&lt;/label&gt; &lt;div id="captcha2"&gt; &lt;p id="wait2" class="show"&gt;正在加载验证码......&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;br&gt; &lt;p id="notice2" class="hide"&gt;请先完成验证&lt;/p&gt; &lt;input class="btn" id="submit2" type="submit" value="提交"&gt;&lt;/form&gt;&lt;!-- 注意，验证码本身是不需要 jquery 库，此处使用 jquery 仅为了在 demo 使用，减少代码量 --&gt;&lt;script src="http://apps.bdimg.com/libs/jquery/1.9.1/jquery.js"&gt;&lt;/script&gt;&lt;!-- 引入 gt.js，既可以使用其中提供的 initGeetest 初始化函数 --&gt;&lt;script src="gt.js"&gt;&lt;/script&gt;&lt;script&gt; var handler1 = function (captchaObj) &#123; $("#submit1").click(function (e) &#123; var result = captchaObj.getValidate(); if (!result) &#123; $("#notice1").show(); setTimeout(function () &#123; $("#notice1").hide(); &#125;, 2000); e.preventDefault(); &#125; &#125;); // 将验证码加到id为captcha的元素里，同时会有三个input的值用于表单提交 captchaObj.appendTo("#captcha1"); captchaObj.onReady(function () &#123; $("#wait1").hide(); &#125;); // 更多接口参考：http://www.geetest.com/install/sections/idx-client-sdk.html &#125;; $.ajax(&#123; url: "geetTest/register1?t=" + (new Date()).getTime(), // 加随机数防止缓存 type: "get", dataType: "json", success: function (data) &#123; // 调用 initGeetest 初始化参数 // 参数1：配置参数 // 参数2：回调，回调的第一个参数验证码对象，之后可以使用它调用相应的接口 initGeetest(&#123; gt: data.gt, challenge: data.challenge, new_captcha: data.new_captcha, // 用于宕机时表示是新验证码的宕机 offline: !data.success, // 表示用户后台检测极验服务器是否宕机，一般不需要关注 product: "float", // 产品形式，包括：float，popup width: "100%" // 更多配置参数请参见：http://www.geetest.com/install/sections/idx-client-sdk.html#config &#125;, handler1); &#125; &#125;); var handler2 = function (captchaObj) &#123; $("#submit2").click(function (e) &#123; var result = captchaObj.getValidate(); if (!result) &#123; $("#notice2").show(); setTimeout(function () &#123; $("#notice2").hide(); &#125;, 2000); &#125; else &#123; $.ajax(&#123; url: 'login/loginAJAX', type: 'POST', // dataType: 'json', data: &#123; username2: $('#username2').val(), password2: $('#password2').val(), geetest_challenge: result.geetest_challenge, geetest_validate: result.geetest_validate, geetest_seccode: result.geetest_seccode &#125;, success: function (data) &#123; alert(data); &#125; &#125;) &#125; e.preventDefault(); &#125;); // 将验证码加到id为captcha的元素里，同时会有三个input的值用于表单提交 captchaObj.appendTo("#captcha2"); captchaObj.onReady(function () &#123; $("#wait2").hide(); &#125;); // 更多接口参考：http://www.geetest.com/install/sections/idx-client-sdk.html &#125;; $.ajax(&#123; url: "geetTest/register2?t=" + (new Date()).getTime(), // 加随机数防止缓存 type: "get", dataType: "json", success: function (data) &#123; // 调用 initGeetest 初始化参数 // 参数1：配置参数 // 参数2：回调，回调的第一个参数验证码对象，之后可以使用它调用相应的接口 initGeetest(&#123; gt: data.gt, challenge: data.challenge, new_captcha: data.new_captcha, // 用于宕机时表示是新验证码的宕机 offline: !data.success, // 表示用户后台检测极验服务器是否宕机，一般不需要关注 product: "popup", // 产品形式，包括：float，popup width: "100%" // 更多配置参数请参见：http://www.geetest.com/install/sections/idx-client-sdk.html#config &#125;, handler2); &#125; &#125;);&lt;/script&gt; Demo演示 1.登录界面，正在加载的验证码 2.验证码展示 3.验证成功之后，提交跳转到登录页面，再次点击提交显示验证失败，一个验证码只能使用一次。（AJAX登录同理） 源码地址 官网Demo gt3-java-sdk github: git@github.com:hdlxt/lxtDaily.git]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>极验验证</tag>
        <tag>滑动验证码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Data JPA实体的生命周期总结]]></title>
    <url>%2F2019%2F01%2F19%2F2019-01-19-Spring%20Data%20JPA%E5%AE%9E%E4%BD%93%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Spring Data JPA是对JPA规范的再次封装和抽象，底层使用HIbernate JPA实现，Hibernate实体有三种状态，而Spring Data JPA实体生命周期也有类似的瞬时、托管、删除、游离四种状态，本文记录对实体四种状态的理解和验证过程。 目录 四种状态 API示例 persist remove merge refresh 参考链接 四种状态 首先以一张图，简单介绍写实体生命周期中四种状态之间的转换关系： 瞬时（New）：瞬时对象，刚New出来的对象，无id，还未和持久化上下文（Persistence Context）建立关联。 托管（Managed）：托管对象，有id，已和持久化上下文（Persistence Context）建立关联，对象属性的所有改动均会影响到数据库中对应记录。 瞬时对象调用em.persist（）方法之后，对象由瞬时状态转换为托管状态 通过find、get、query等方法，查询出来的对象为托管状态 游离状态的对象调用em.merge方法，对象由游离状态转换为托管状态 游离（Datached）：游离对象，有id值，但没有和持久化上下文（Persistence Context）建立关联。 托管状态对象提交事务之后，对象状态由托管状态转换为游离状态 托管状态对象调用em.clear()方法之后，对象状态由托管状态转换为游离状态 New出来的对象，id赋值之后，也为游离状态 删除（Removed）：执行删除方法（em.remove()）但未提交事务的对象，有id值，没有和持久化上下文（Persistence Context）建立关联，即将从数据库中删除。 API示例 针对JPA规范的四个方法，写了一个简单的Demo，进行了一一的验证，以下进行验证过程说明，完整代码传送门：https://github.com/hdlxt/SpringDataJpaDemo.git 整体结构如下： persist 不同状态下执行em.persist()方法产生结果： 瞬时态：转化为托管态 托管态：不发生改变，但执行instert语句 删除态：转化为托管态 游离态：抛异常 验证删除态和游离态持久化如下: 1.持久化删除态 代码 12345678910111213141516171819202122232425262728 /** * 持久化删除态的对象 *@param id * @return */ @RequestMapping("/persistRemove/&#123;id&#125;") public String persistRemove(@PathVariable("id")Long id)&#123; try &#123; User user = userDao.findById(id); userDao.persistRemove(user); &#125;catch (Exception e)&#123; logger.error("持久化一个删除态的对象!",e); return REPONSE_ERR; &#125; return REPONSE_SUCCESS; &#125;-------------------------------------------------------- /** * 持久化删除态的对象 * * @param user */ @Override public void persistRemove(User user) &#123; remove(user); persist(user); user.setName("persist remove success!"); &#125; 步骤 http://localhost:8080/user/persisNew/lxt/001，插入一条数据 http://localhost:8080/user/list，检查插入结果，并获取`id` http://localhost:8080/user/persistRemove/{id} ,返回SUCCESS！ http://localhost:8080/user/list 查看结果 结果：结果数据并未删除，而且name由lxt变为persist remove success! 2.持久化游离态 代码 1234567891011121314151617/** * 持久化游离态的对象 *@param id * @return */ @RequestMapping("/persisDetached/&#123;id&#125;") public String persisDetached(@PathVariable("id")Long id)&#123; try &#123; User user = userDao.findById(id); userDao.clear(); userDao.persist(user); &#125;catch (Exception e)&#123; logger.error("持久化一个游离态的对象!",e); return REPONSE_ERR; &#125; return REPONSE_SUCCESS; &#125; 步骤 http://localhost:8080/user/list，获取`id` http://localhost:8080/user/persisDetached/{id} 返回ERROR！ 结果：抛异常 1234567892019-01-26 00:00:34.090 ERROR 5228 --- [io-8080-exec-10] c.e.demo.controller.UserController : 持久化一个游离态的对象!org.springframework.dao.InvalidDataAccessApiUsageException: detached entity passed to persist: com.example.demo.entity.User; nested exception is org.hibernate.PersistentObjectException: detached entity passed to persist: com.example.demo.entity.User at org.springframework.orm.jpa.vendor.HibernateJpaDialect.convertHibernateAccessException(HibernateJpaDialect.java:317) ~[spring-orm-5.1.4.RELEASE.jar:5.1.4.RELEASE] at org.springframework.orm.jpa.vendor.HibernateJpaDialect.translateExceptionIfPossible(HibernateJpaDialect.java:253) ~[spring-orm-5.1.4.RELEASE.jar:5.1.4.RELEASE] at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.translateExceptionIfPossible(AbstractEntityManagerFactoryBean.java:527) ~[spring-orm-5.1.4.RELEASE.jar:5.1.4.RELEASE] at org.springframework.dao.support.ChainedPersistenceExceptionTranslator.translateExceptionIfPossible(ChainedPersistenceExceptionTranslator.java:61) ~[spring-tx-5.1.4.RELEASE.jar:5.1.4.RELEASE] at org.springframework.dao.support.DataAccessUtils.translateIfNecessary(DataAccessUtils.java:242) ~[spring-tx-5.1.4.RELEASE.jar:5.1.4.RELEASE] .... remove 不同状态下执行em.remove()方法产生结果： 瞬时态：对状态无影响，后台打印日志 托管态：转化为托管态 删除态：无影响，什么都不发生 游离态：抛异常Removing a detached instance com.example.demo.entity.User... 验证过程如下： 1.瞬时态 代码 12345678910111213141516/** * 删除new出来的对象 *@param id * @return */@RequestMapping("/removeNew")public String removeNew()&#123; try &#123; User user = new User().setName("lxt").setNumber("007"); userDao.remove(user); &#125;catch (Exception e)&#123; logger.error("删除(remove)一个new的对象!",e); return REPONSE_ERR; &#125; return REPONSE_SUCCESS;&#125; 步骤 http://localhost:8080/user/removeNew 结果：返回SUCCESS!后台输出日志 12019-01-26 00:17:32.811 INFO 10136 --- [nio-8080-exec-5] o.h.e.i.DefaultDeleteEventListener : HHH000114: Handling transient entity in delete processing 2.删除态 代码 123456789101112131415161718192021222324252627 /** * 删除 删除态对象 *@param id * @return */ @RequestMapping("/removeRemove/&#123;id&#125;") public String removeRemove(@PathVariable("id")Long id)&#123; try &#123; User user = userDao.findById(id); userDao.removeRemove(user); &#125;catch (Exception e)&#123; logger.error("删除(remove)一个删除态的对象!",e); return REPONSE_ERR; &#125; return REPONSE_SUCCESS; &#125;----------------------------------------------------- /** * 删除 删除态的对象 * * @param user */ @Override public void removeRemove(User user) &#123; remove(user); remove(user); &#125; 步骤 http://localhost:8080/user/list，获取`id` http://localhost:8080/user/removeRemove/{id} 结果：返回SUCCESS！，后台输出一个查询sql和一个删除sql，证明第二个删除没有影响 12Hibernate: select user0_.id as id1_0_, user0_.name as name2_0_, user0_.number as number3_0_ from t_user user0_ where user0_.id=?Hibernate: delete from t_user where id=? 3.游离态 代码 123456789101112131415161718192021222324252627 /** * 删除游离态对象 *@param id * @return */ @RequestMapping("/removeDetached/&#123;id&#125;") public String removeDetached(@PathVariable("id")Long id)&#123; try &#123; User user = userDao.findById(id); userDao.removeDetached(user); &#125;catch (Exception e)&#123; logger.error("删除(remove)一个游离态的对象!",e); return REPONSE_ERR; &#125; return REPONSE_SUCCESS; &#125;------------------------------------------------------------- /** * 删除游离态的对象 * * @param user */ @Override public void removeDetached(User user) &#123; clear(); remove(user); &#125; 步骤 http://localhost:8080/user/list，获取`id` http://localhost:8080/user/persisDetached/{id} 结果：返回ERROR!抛异常 123456782019-01-26 00:14:11.071 ERROR 5228 --- [io-8080-exec-10] c.e.demo.controller.UserController : 删除(remove)一个游离态的对象!org.springframework.dao.InvalidDataAccessApiUsageException: Removing a detached instance com.example.demo.entity.User#5; nested exception is java.lang.IllegalArgumentException: Removing a detached instance com.example.demo.entity.User#5 at org.springframework.orm.jpa.EntityManagerFactoryUtils.convertJpaAccessExceptionIfPossible(EntityManagerFactoryUtils.java:373) ~[spring-orm-5.1.4.RELEASE.jar:5.1.4.RELEASE] at org.springframework.orm.jpa.vendor.HibernateJpaDialect.translateExceptionIfPossible(HibernateJpaDialect.java:255) ~[spring-orm-5.1.4.RELEASE.jar:5.1.4.RELEASE] at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.translateExceptionIfPossible(AbstractEntityManagerFactoryBean.java:527) ~[spring-orm-5.1.4.RELEASE.jar:5.1.4.RELEASE] at org.springframework.dao.support.ChainedPersistenceExceptionTranslator.translateExceptionIfPossible(ChainedPersistenceExceptionTranslator.java:61) ~[spring-tx-5.1.4.RELEASE.jar:5.1.4.RELEASE] at org.springframework.dao.support.DataAccessUtils.translateIfNecessary(DataAccessUtils.java:242) ~[spring-tx-5.1.4.RELEASE.jar:5.1.4.RELEASE] merge 不同状态下执行em.merge()方法产生结果： 瞬时态：提交到数据库，返回一个新的托管态的对象 托管态：根据原对象返回一个新的托管态的对象 删除态：抛异常org.springframework.dao.InvalidDataAccessApiUsageException: org.hibernate.ObjectDeletedException: deleted instance passed to merge: [com.example.demo.entity.User#&lt;null&gt;]... 游离态：提交到数据库，进行更新或插入，返回一个新的托管态的对象 合并（merge）删除态和游离态验证过程如下： 1.删除态 代码 123456789101112131415161718192021222324252627 /** * 持久化删除态的对象 *@param id * @return */ @RequestMapping("/mergeRemove/&#123;id&#125;") public String mergeRemove(@PathVariable("id")Long id)&#123; try &#123; User user = userDao.findById(id); userDao.mergeRemove(user); &#125;catch (Exception e)&#123; logger.error("合并(merge)一个删除态的对象!",e); return REPONSE_ERR; &#125; return REPONSE_SUCCESS; &#125;-------------------------------------------------------------------- /** * 合并删除态的对象 * * @param user */ @Override public void mergeRemove(User user) &#123; remove(user); merge(user); &#125; 步骤 http://localhost:8080/user/list，获取`id` http://localhost:8080/user/mergeRemove/{id} 结果：返回ERROR抛异常！ 1234567892019-01-26 00:23:01.187 INFO 10136 --- [nio-8080-exec-3] o.h.h.i.QueryTranslatorFactoryInitiator : HHH000397: Using ASTQueryTranslatorFactoryHibernate: select user0_.id as id1_0_, user0_.name as name2_0_, user0_.number as number3_0_ from t_user user0_ where user0_.id=?2019-01-26 00:23:01.322 ERROR 10136 --- [nio-8080-exec-3] c.e.demo.controller.UserController : 合并(merge)一个删除态的对象!org.springframework.dao.InvalidDataAccessApiUsageException: org.hibernate.ObjectDeletedException: deleted instance passed to merge: [com.example.demo.entity.User#&lt;null&gt;]; nested exception is java.lang.IllegalArgumentException: org.hibernate.ObjectDeletedException: deleted instance passed to merge: [com.example.demo.entity.User#&lt;null&gt;] at org.springframework.orm.jpa.EntityManagerFactoryUtils.convertJpaAccessExceptionIfPossible(EntityManagerFactoryUtils.java:373) ~[spring-orm-5.1.4.RELEASE.jar:5.1.4.RELEASE] at org.springframework.orm.jpa.vendor.HibernateJpaDialect.translateExceptionIfPossible(HibernateJpaDialect.java:255) ~[spring-orm-5.1.4.RELEASE.jar:5.1.4.RELEASE] at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.translateExceptionIfPossible(AbstractEntityManagerFactoryBean.java:527) ~[spring-orm-5.1.4.RELEASE.jar:5.1.4.RELEASE] at org.springframework.dao.support.ChainedPersistenceExceptionTranslator.translateExceptionIfPossible(ChainedPersistenceExceptionTranslator.java:61) ~[spring-tx-5.1.4.RELEASE.jar:5.1.4.RELEASE] 2.游离态 代码 1234567891011121314151617181920212223242526272829 /** * 持久化游离态的对象 *@param id * @return */ @RequestMapping("/mergeDetached/&#123;id&#125;") public String mergeDetached(@PathVariable("id")Long id)&#123; try &#123; User user = userDao.findById(id); userDao.mergeDetached(user); &#125;catch (Exception e)&#123; logger.error("合并(merge)一个游离态的对象!",e); return REPONSE_ERR; &#125; return REPONSE_SUCCESS; &#125;--------------------------------------------------------------- /** * 合并游离态的对象 * * @param user */ @Override public void mergeDetached(User user) &#123; clear(); User newUser = merge(user); newUser.setName("newUser merge detached success!"); user.setName("user merge detached success!"); &#125; 步骤 http://localhost:8080/user/list，获取`id` http://localhost:8080/user/mergeDetached/5，返回`SUCCESS!` http://localhost:8080/user/list，查看 结果:对应实体的name值变为newUser merge detached success!，证明返回新的对象为托管态对象 2.游离态 refresh 方法可以保证当前的实例与数据库中的实例的内容一致，注意：是反向同步，将数据库中的数据同步到实体中 不同状态下执行em.refresh()方法产生结果： 瞬时态：抛异常org.springframework.dao.InvalidDataAccessApiUsageException: Entity not managed; 托管态： 将数据库中的数据同步到实体中，返回一个托管态的对象。 删除态：抛异常org.springframework.dao.InvalidDataAccessApiUsageException: Entity not managed; 游离态：抛异常org.springframework.dao.InvalidDataAccessApiUsageException: Entity not managed; 总结：只有被托管的对象才可以被refresh。 1.瞬时态 代码 12345678910111213141516/** * 刷新new出来的对象 *@param id * @return */@RequestMapping("/refreshNew")public String refreshNew()&#123; try &#123; User user = new User().setName("lxt").setNumber("007"); userDao.refresh(user); &#125;catch (Exception e)&#123; logger.error("刷新(refresh)一个new的对象!",e); return REPONSE_ERR; &#125; return REPONSE_SUCCESS;&#125; 步骤 http://localhost:8080/user/refreshNew 结果：返回ERROR!抛异常 12345672019-01-26 00:38:18.037 ERROR 10136 --- [nio-8080-exec-3] c.e.demo.controller.UserController : 刷新(refresh)一个new的对象!org.springframework.dao.InvalidDataAccessApiUsageException: Entity not managed; nested exception is java.lang.IllegalArgumentException: Entity not managed at org.springframework.orm.jpa.EntityManagerFactoryUtils.convertJpaAccessExceptionIfPossible(EntityManagerFactoryUtils.java:373) ~[spring-orm-5.1.4.RELEASE.jar:5.1.4.RELEASE] at org.springframework.orm.jpa.vendor.HibernateJpaDialect.translateExceptionIfPossible(HibernateJpaDialect.java:255) ~[spring-orm-5.1.4.RELEASE.jar:5.1.4.RELEASE] at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.translateExceptionIfPossible(AbstractEntityManagerFactoryBean.java:527) ~[spring-orm-5.1.4.RELEASE.jar:5.1.4.RELEASE] at org.springframework.dao.support.ChainedPersistenceExceptionTranslator.translateExceptionIfPossible(ChainedPersistenceExceptionTranslator.java:61) ~[spring-tx-5.1.4.RELEASE.jar:5.1.4.RELEASE] 2.托管态： 代码 12345678910111213141516171819202122232425262728 /** * 刷新托管态对象 *@param id * @return */ @RequestMapping("/refreshManaged/&#123;id&#125;") public String refreshManaged(@PathVariable("id")Long id)&#123; try &#123; User user = userDao.findById(id); userDao.refreshManaged(user); &#125;catch (Exception e)&#123; logger.error("刷新(refresh)一个托管态的对象!",e); return REPONSE_ERR; &#125; return REPONSE_SUCCESS; &#125;------------------------------------------------------------------ /** * 刷新托管态的对象 * * @param user */ @Override public void refreshManaged(User user) &#123; user.setName("refresh before!"); refresh(user); logger.info("user:"+user); &#125; 步骤 http://localhost:8080/user/list，获取`id` http://localhost:8080/user/refreshManaged/{id},返回`SUCCESS` http://localhost:8080/user/list 结果:数据库中数据并无变化，日志打印为数据库中查询出的值，并未打印refresh before! 3.删除态 代码 1234567891011121314151617181920212223242526272829 /** * 刷新删除态对象 *@param id * @return */ @RequestMapping("/refreshRemove/&#123;id&#125;") public String refreshRemove(@PathVariable("id")Long id)&#123; try &#123; User user = userDao.findById(id); userDao.refreshRemove(user); &#125;catch (Exception e)&#123; logger.error("刷新(refresh)一个删除态的对象!",e); return REPONSE_ERR; &#125; return REPONSE_SUCCESS; &#125;---------------------------------------------------------------------- /** * 刷新删除态的对象 * * @param user */ @Override public void refreshRemove(User user) &#123; remove(user); user.setName("refresh remove before！"); refresh(user); user.setName("refresh remove after！"); &#125; 步骤 http://localhost:8080/user/list，获取`id` http://localhost:8080/user/refreshRemove/{id} 结果：返回ERROR!抛异常 12345672019-01-26 00:40:57.713 ERROR 10136 --- [nio-8080-exec-3] c.e.demo.controller.UserController : 刷新(refresh)一个删除态的对象!org.springframework.dao.InvalidDataAccessApiUsageException: Entity not managed; nested exception is java.lang.IllegalArgumentException: Entity not managed at org.springframework.orm.jpa.EntityManagerFactoryUtils.convertJpaAccessExceptionIfPossible(EntityManagerFactoryUtils.java:373) ~[spring-orm-5.1.4.RELEASE.jar:5.1.4.RELEASE] at org.springframework.orm.jpa.vendor.HibernateJpaDialect.translateExceptionIfPossible(HibernateJpaDialect.java:255) ~[spring-orm-5.1.4.RELEASE.jar:5.1.4.RELEASE] at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.translateExceptionIfPossible(AbstractEntityManagerFactoryBean.java:527) ~[spring-orm-5.1.4.RELEASE.jar:5.1.4.RELEASE] at org.springframework.dao.support.ChainedPersistenceExceptionTranslator.translateExceptionIfPossible(ChainedPersistenceExceptionTranslator.java:61) ~[spring-tx-5.1.4.RELEASE.jar:5.1.4.RELEASE] 4.游离态 代码 123456789101112131415161718192021222324252627 /** * 刷新游离态对象 *@param id * @return */ @RequestMapping("/refreshDetached/&#123;id&#125;") public String refreshDetached(@PathVariable("id")Long id)&#123; try &#123; User user = userDao.findById(id); userDao.refreshDetached(user); &#125;catch (Exception e)&#123; logger.error("刷新(refresh)一个游离态的对象!",e); return REPONSE_ERR; &#125; return REPONSE_SUCCESS; &#125;---------------------------------------------------------------------- /** * 刷新游离态的对象 * * @param user */ @Override public void refreshDetached(User user) &#123; clear(); refresh(user); &#125; 步骤 http://localhost:8080/user/list，获取`id` http://localhost:8080/user/refreshDetached/{id},` 结果:返回ERROR！抛异常！ 12345672019-01-26 00:42:09.598 ERROR 10136 --- [nio-8080-exec-7] c.e.demo.controller.UserController : 刷新(refresh)一个游离态的对象!org.springframework.dao.InvalidDataAccessApiUsageException: Entity not managed; nested exception is java.lang.IllegalArgumentException: Entity not managed at org.springframework.orm.jpa.EntityManagerFactoryUtils.convertJpaAccessExceptionIfPossible(EntityManagerFactoryUtils.java:373) ~[spring-orm-5.1.4.RELEASE.jar:5.1.4.RELEASE] at org.springframework.orm.jpa.vendor.HibernateJpaDialect.translateExceptionIfPossible(HibernateJpaDialect.java:255) ~[spring-orm-5.1.4.RELEASE.jar:5.1.4.RELEASE] at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.translateExceptionIfPossible(AbstractEntityManagerFactoryBean.java:527) ~[spring-orm-5.1.4.RELEASE.jar:5.1.4.RELEASE] at org.springframework.dao.support.ChainedPersistenceExceptionTranslator.translateExceptionIfPossible(ChainedPersistenceExceptionTranslator.java:61) ~[spring-tx-5.1.4.RELEASE.jar:5.1.4.RELEASE] 参考链接 JPA EntityManager的四个主要方法 ——persist,merge,refresh和remove JPA 实体生命周期理解和总结]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring Data JPA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Data JPA 2.0X版本之后findOne方法被findById方法替换]]></title>
    <url>%2F2019%2F01%2F13%2F2019-01-13-Spring%20Data%20JPA%202.0X%E7%89%88%E6%9C%AC%E4%B9%8B%E5%90%8EfindOne%E6%96%B9%E6%B3%95%E8%A2%ABfindById%E6%96%B9%E6%B3%95%E6%9B%BF%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[在使用Spring Boot2.0整合Spring Data JPA时，发现继承JpaRepository接口之后无findOne方法，经查阅资料之后，发现已被新的APIfindById方法替换，新的API结合了java8的语法Optional（一个专门用于避免空指针NPE而开发的类），使用起来更为方便。 目录 API说明 使用示例 参考链接 API说明 新的API接口如下，去掉了findOne方法，添加了返回值为Optional&lt;T&gt;的findById方法,调用findById方法之后，返回Optional的实例，调用Optional的get()方法即可获取到实体。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package org.springframework.data.repository;@NoRepositoryBeanpublic interface CrudRepository&lt;T, ID&gt; extends Repository&lt;T, ID&gt; &#123; &lt;S extends T&gt; S save(S var1); &lt;S extends T&gt; Iterable&lt;S&gt; saveAll(Iterable&lt;S&gt; var1); //新的根据主键获取实体的方法 Optional&lt;T&gt; findById(ID var1); boolean existsById(ID var1); Iterable&lt;T&gt; findAll(); Iterable&lt;T&gt; findAllById(Iterable&lt;ID&gt; var1); long count(); void deleteById(ID var1); void delete(T var1); void deleteAll(Iterable&lt;? extends T&gt; var1); void deleteAll();&#125;package java.util;public final class Optional&lt;T&gt; &#123; .... /** * If a value is present in this &#123;@code Optional&#125;, returns the value, * otherwise throws &#123;@code NoSuchElementException&#125;. * 如果此@code可选中存在值，则返回该值，否则抛出@code nosuchelementexception。 * @return the non-null value held by this &#123;@code Optional&#125; * @throws NoSuchElementException if there is no value present * * @see Optional#isPresent() */ public T get() &#123; if (value == null) &#123; throw new NoSuchElementException("No value present"); &#125; return value; &#125; ....&#125; 使用示例 根据上面的Optional的get()方法API注释说明可知，直接调用get()方法可能会跑出异常，以下为简单参考示例：1234567891011121314151617//不建议姿势try &#123; User user1 = userDao.findById(1L).get();&#125;catch (Exception e)&#123; //实体不存在，捕获异常&#125;//相对费劲姿势Optional&lt;User&gt; user2 = userDao.findById(1L);if(user2.isPresent())&#123; //实体存在&#125;else&#123; //实体不存在&#125;//建议姿势，存在返回实体，不存在不抛异常，返回nullUser user3 = userDao.findById(1L).orElse(null); 参考链接 https://blog.csdn.net/u012211603/article/details/79828277]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring Data JPA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Data JPA 1.0x版本中getOne和findOne区别]]></title>
    <url>%2F2019%2F01%2F13%2F2019-01-13-Spring%20Data%20JPA%201.0x%E7%89%88%E6%9C%AC%E4%B8%ADgetOne%E5%92%8CfindOne%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[上个项目初期，由于不熟悉Spring Data JPA框架，在根据主键获取实体时，findOne和getOne混用，留下了不少坑，做个记录，简要说明下区别。 目录 API说明 使用说明 API说明 123456789101112131415161718/** * Retrieves an entity by its id. * * @param id must not be &#123;@literal null&#125;. * @return the entity with the given id or &#123;@literal null&#125; if none found * 返回具有给定ID的实体，如果找不到，则返回@literal null * @throws IllegalArgumentException if &#123;@code id&#125; is &#123;@literal null&#125; */T findOne(ID id);/** * Returns a reference to the entity with the given identifier. * * @param id must not be &#123;@literal null&#125;. * @return a reference to the entity with the given identifier. * 返回对具有给定标识符的实体的引用。(延迟加载) * @see EntityManager#getReference(Class, Object) */T getOne(ID id); 使用说明 findOne和getOne重点即为翻译部分内容对比，两者加载策略和返回内容不同 findOne方法为即时加载，执行该方法之后，立即执行查询的sql语句，返回结果，有对应实体则返回实体对象，如果没有实体对象，则返回null。（Spring Data JPA 2.0X版本之后findOne方法被findById方法替换） getOne方法为延迟加载 执行该方法之后，并不会执行对应的查询sql语句，而是返回一个带有id的代理对象，无论数据库中是否有该主键对应的实体，都不会返回null，即不可用xxx==null来判断是否有返回结果。 当获取该代理对象的其他属性时，会执行执行查询sql，如果数据库中有对应的实体，则返回实体对象；如果数据中无实体对象，则抛出EntityNotFoundException异常，如下：]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring Data JPA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown常用语法回顾与熟悉]]></title>
    <url>%2F2018%2F12%2F31%2F2018-12-31-MarkDown%E5%9B%9E%E9%A1%BE%E4%B8%8E%E7%86%9F%E6%82%89%2F</url>
    <content type="text"><![CDATA[这两天利用元旦假期的空闲时间捣鼓了一个初版的博客，目前还有一些小问题待完善，后续有精力再继续完善。这第一篇就用于熟悉MarkDown语法了，为以后奠定基础。 目录 标题 锚点 段落与换行 区块引用 列表 代码 强调 自动链接 表格 分割线 图片 标题 在文字前面添加【#】即可创建一至六级标题，详情如下： # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 效果如下： 锚点 利用锚点可进行页面内跳转（文章目录即为锚点语法制作），详情如下： [**标题**](#title) 【#】后面的title对应下面的id=&#39;title&#39; &lt;h2 id=&#39;title&#39;&gt;标题&lt;/h2&gt; 效果： 点击【标题】目录可自动跳转到下面的标题模块 段落与换行 段落：段落就是连续行上的文本, 一个或多个空行划分不同的段落. (空行的含义就只要是看起来是空行就行了 – 即使包含了 spaces 或者 等空白符也是空行.) 普通段落不应该使用缩进. 换行：只需要在行尾加上两个及以上的空格, 即可自动换行 区块引用 >区块引用 >&gt;这是嵌套区块引用 效果： 区块引用 这是嵌套区块引用 列表 无序列表可用【+】、【*】、【-】符号表示无序列表(符号和文字之间有一个空格)，如下： -（+*） 第一项-（+*） 第二项 （+*）第三项 效果： 第一项 第二项 第三项 无序列表用数字加【.】来标识(【.】符号和文字之间有一个空格)，如下： 第一项 第二项 第三项 效果： 第一项 第二项 第三项 代码 代码区块:语法```语言XXXXXX```。如下:普通段落：void main(){print(“Hello World!”);} java代码块：1234void main()&#123;print("Hello World!");&#125; 强调 在强调内容两侧分别加上【*】或者【_】，如： *斜体*，_斜体_**粗体**，__粗体__ 效果： 斜体，_斜体_粗体，粗体 自动链接 链接有两种形式生成：行内式和参考式。 行内式: [XiaoTong’s Blog](https://hdlxt.github.io/)。 效果： XiaoTong’s Blog。 参考式 [XiaoTong’s Blog]1[1]:https://hdlxt.github.io/ 效果： XiaoTong’s Blog。 水平分割线 如果一行中只有三个以上的连字符, 星号, 或者下划线则会在该位置生成一个 &lt;hr /&gt; 标签. 星号和连字符之间的空格也是允许的. 下面的例子都会生成一条水平线:如： **-–\ - - - 效果： 图片 通常, 要用 “原生” 的语法在纯文本格式中插入图片是很困难的.Markdown 使用了类似链接的语法来插入图片, 包含两种形式: 内联 和 引用.内联图片语法如下:![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg “Optional title”)也就是:一个感叹号: !;紧跟着一对方括号, 包含了图片的 alt 属性;紧跟着一对圆括号, 包含了图片的 URL 或者路径, 以及一个可选的用单引号或双引号包裹的 title 属性.引用图片语法如下:![Alt text][id]“id” 是图片引用的名称. 图片引用使用链接定义的相同语法:[id]: url/to/image “Optional title attribute”Markdown 没有语法指定图片尺寸; 如果需要指定图片尺寸, 可以使用HTML&lt;img&gt; 标签.示例如： ![avatar](/images/avatar.jpg) 效果：]]></content>
      <categories>
        <category>编辑工具</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
</search>
